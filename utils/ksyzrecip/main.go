/* -*- compile-command: "go build" -*- */
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/syzkaller/prog"
)

const (
	header string = `/* autogenerated by ksyzrecip (by michal.lach@samsung.com) */
#include <linux/module.h>
#include <linux/interval_tree_generic.h>

#include "kflat.h"
#include "kflat_recipe.h"
`
)

var (
	outputPath string
	syzArch    string
	fokaPath   string
	paths      []string
)

func globFilesFromPaths(paths []string, glob string) []string {
	var files []string = nil

	for _, path := range paths {
		globbed, err := filepath.Glob(filepath.Join(path, glob))
		if err != nil {
			return make([]string, 0, 0)
		}

		files = append(files, globbed...)
	}

	return files
}

func stripModuleNames(name string) string {
	if strings.Contains(name, " [") {
		return strings.Split(name, " [")[0]
	} else if strings.Contains(name, ".cfi_jt") {
		return strings.Split(name, ".cfi_jt")[0]
	}

	return name
}

func generateRecipes(syscalls []*prog.Syscall, outputPath string, pathMap SyscallPathMap, foka Foka) {
	var f *os.File = nil
	usedRecipes := make(map[string]struct{})

	f, err := os.Create(outputPath)
	if err != nil {
		panic(err)
	}

	f.WriteString(header)

	triggers := make(map[string]TriggerFunction)
	for _, syscall := range syscalls {
		if syscall.CallName != "ioctl" || len(syscall.Args) < 3 {
			continue
		}

		derefed, ok := syscall.Args[2].Type.(*prog.PtrType)
		if !ok {
			continue
		}

		inner, ok := derefed.Elem.(*prog.StructType)
		if !ok {
			continue
		}

		flats, err := generateFlatteningFunctions(*inner)
		if err != nil {
			continue
		}

		for _, flat := range flats {
			if _, ok := usedRecipes[flat.Name]; ok {
				continue
			}

			f.WriteString("\n" + flat.Declaration() + "\n")
		}

		for _, flat := range flats {
			if _, ok := usedRecipes[flat.Name]; ok {
				continue
			}

			f.WriteString("\n" + flat.Definition() + "\n")

			usedRecipes[flat.Name] = struct{}{}
		}

		paths := pathMap[syscall.Name]
		path := paths[len(paths)-1]
		if path[len(path)-1] == '\x00' {
			path = path[:len(path)-1]
		}

		ioctlsByPath := foka[path].Ioctl
		if len(ioctlsByPath) <= 0 {
			panic("no foka paths for " + syscall.Name + " function")
		}

		originalName := stripModuleNames(ioctlsByPath[len(ioctlsByPath)-1])
		triggers[originalName] = TriggerFunction{
			Name:               "syz_trigger_" + originalName,
			FlattenedType:      inner.TemplateName(),
			FlattenedSize:      calculateActualSize(inner),
			TargetFunctionName: originalName,
			NodePath:           path,
		}
	}

	for _, t := range triggers {
		f.WriteString(t.Definition())
		f.WriteString("\n\n")
	}

	f.WriteString("KFLAT_RECIPE_LIST(\n")

	for _, t := range triggers {
		f.WriteString("\t")
		f.WriteString(t.Declaration())
	}

	f.WriteString(");\n\n")

	f.WriteString(`KFLAT_RECIPE_MODULE("Automatically generated kflat module from syzkaller recipes");\n`)
}

func init() {
	flag.StringVar(&outputPath, "output", "_gen.c", "path to outputted file")
	flag.StringVar(&syzArch, "arch", "arm64", "targeted arch of syzkaller descriptions (sizes or constants might differ) from sys/targets package")
	flag.StringVar(&fokaPath, "foka", "foka_v2.json", "path to FOKA output")

	flag.Usage = func() {
		out := flag.CommandLine.Output()

		fmt.Fprintf(out, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintf(out, "\n")
		fmt.Fprintf(out, "Most importantly ksyzrecip takes at least 1 positional argument which is a path to folder with syzkaller descriptions.\n")
		fmt.Fprintf(out, "Normally that would be in syzkaller/sys/$TARGETOS\n")
	}

	flag.Parse()

	if flag.NArg() == 0 {
		flag.Usage()
		os.Exit(0)
	}

	paths = flag.Args()
}

func main() {
	if len(os.Args) <= 1 {
		flag.Usage()
		os.Exit(0)
	}

	descriptions := globFilesFromPaths(paths, "*.txt")
	constants := globFilesFromPaths(paths, "*.const")

	_, syscalls, _, err := tryCompileFromPaths(descriptions, constants, syzArch)
	if err != nil {
		panic(err)
	}

	fokaFile, err := os.ReadFile(fokaPath)
	if err != nil {
		panic(err)
	}

	var foka Foka = nil
	err = json.Unmarshal(fokaFile, &foka)
	if err != nil {
		panic(err)
	}

	pathMap := createSyscallToPathMap(syscalls)
	generateRecipes(syscalls, outputPath, pathMap, foka)
}
