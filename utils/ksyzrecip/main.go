/* -*- compile-command: "go build" -*- */
package main

import (
	"errors"
	"flag"
	"fmt"
	"github.com/google/syzkaller/pkg/ast"
	"github.com/google/syzkaller/pkg/compiler"
	"github.com/google/syzkaller/prog"
	"github.com/google/syzkaller/sys/targets"
	"os"
	"path/filepath"
	"strings" 
)

const (
	header string = `/* autogenerated by ksyzrecip (by michal.lach@samsung.com) */
#include <linux/module.h>
#include <linux/interval_tree_generic.h>

#include "kflat.h"
#include "kflat_recipe.h"

`
)

var (
	lastFile  string
	lastMsg   string
	outputDir string
	syzArch   string
	paths     []string
)

func compileErrorHandler(pos ast.Pos, msg string) {
	lastFile = pos.File
	lastMsg = msg
}

func shouldQueue(typ prog.Type) (bool, prog.Type, bool) {
	var isPointer bool = false
again:
	switch typ.(type) {
	case *prog.StructType:
		return isPointer, typ, true
	case *prog.UnionType:
		return isPointer, typ, true
	case *prog.PtrType:
		typ = typ.(*prog.PtrType).Elem
		isPointer = true
		goto again
	}

	return isPointer, nil, false
}

func getRecordFields(syzType interface{}) ([]prog.Field, error) {
	switch t := syzType.(type) {
	case *prog.StructType:
		return t.Fields, nil
	case *prog.UnionType:
		return t.Fields, nil
	default:
		break
	}

	return nil, errors.New("not a record type")
}



func deduceDependantTypes(targetType prog.Type) map[string]prog.Type {
	// Map containing every type which should have its own flattening function.
	types := make(map[string]prog.Type)
	traversed := make(map[string]int)
	typQueue := make([]prog.Type, 1)
	typQueue[0] = targetType

	for len(typQueue) > 0 {
		var iter prog.Type
		typ := typQueue[0]
		iter = typ
		typQueue = append(typQueue[:0], typQueue[1:]...)
		if _, ok := types[typ.Name()]; ok {
			val, ok := traversed[typ.TemplateName()]
			if ok && val > 1 {
				continue
			}
		}

		// We don't queue pointers, but the entry might just be a pointer so this is here just in case.
		ptr, ok := typ.(*prog.PtrType)
		if ok {
			iter = ptr.Elem
		}

		// This will iterate only over structs and unions, so all other potentially queued types are for sure discarded by now.
		fields, _ := getRecordFields(iter)
		// We should queue up array elements type
		for _, field := range fields {
			// Queue up only records and if field is a pointer to a record, dereference it and queue it
			pointer, t, ok := shouldQueue(field.Type)
			if ok {
				typQueue = append(typQueue, t)
				if pointer {
					types[t.TemplateName()] = t
				}
			}
		}

		traversed[iter.TemplateName()] += 1
	}

	return types
}

func aggregateFromPointer(subType prog.Type, field string, offset uint64) (Aggregate, bool) {
	switch t := subType.(type) {
	case *prog.StructType:
		size := calculateActualSize(t)
		common := AggregateCommon {
			TypeName: t.TemplateName(),
			TypeSize: &size,
			FieldName: field,
			FieldOffset: offset,
		}

		aggregate := &RecordAggregate {
			AggregateCommon: common,
			IsUnion: false,
		}
		return aggregate, true
	case *prog.UnionType:
		size := calculateActualSize(t)
		common := AggregateCommon {
			TypeName: t.TemplateName(),
			TypeSize: &size,
			FieldName: field,
			FieldOffset: offset,
		}

		aggregate := &RecordAggregate {
			AggregateCommon: common,
			IsUnion: true,
		}
		return aggregate, true
	}

	return nil, false
}

func generateRecipe(insideType prog.StructType) ([]*FlatHandler, error) {
	types := deduceDependantTypes(&insideType)

	// Add the root type as well
	types[insideType.Name()] = &insideType
	recipeTypes := make([]*FlatHandler, 0)

	for _, iter := range types {
		fields, err := getRecordFields(iter)
		if err != nil {
			continue
		}

		var fieldOffset uint64 = 0

		flat := &FlatHandler {
			Name: iter.TemplateName(),
			Size: calculateActualSize(iter).Size,
			Aggregates: make(map[string]Aggregate),
		}

		for _, field := range fields {
			switch t := field.Type.(type) {
			case *prog.PtrType:
				aggregate, ok := aggregateFromPointer(t.Elem, field.Name, fieldOffset)
				if !ok {
					continue
				}

				flat.Aggregates[field.Name] = aggregate
			case *prog.ArrayType:
				break
			}

			fieldOffset += calculateActualSize(field.Type).Size
		}

		// syzlang specifications says len[] it can point to a
		// field in a child of current parent record.
		// As of 8.04.23, this does not happen in base syzkaller recipes
		// However, some descriptions use len to refer to its parent.
		// I don't really know how to express that in terms of KFLAT recipes
		// so I don't have an idea how to implement this feature.
		// Here we are considering lengths only on sibling fields.
		for _, field := range fields {
			t, ok := field.Type.(*prog.LenType)
			if !ok || len(t.Path) != 1 || t.Path[0] == "parent" {
				continue
			}

			// t.BitSize == 0 is len[] (if len's argument is a pointer, turn it into array)
			// t.BitSize == 8 is bytesize[] (
			// t.BitSizeN == 8 * N is bytesizeN[] (for N byte words)
			// !(t.BitSize % 8) is bitsize[]

			aggregate, ok := flat.Aggregates[t.Path[0]]
			if t.BitSize != 0 || !ok {
				continue
			}

			lengthWrapper := &FieldSize {
				FieldName: field.Name,
			}

			common := &AggregateCommon {
				TypeName: aggregate.Name(),
				FieldName: aggregate.Field(),
				FieldOffset: aggregate.Offset(),
				TypeSize: lengthWrapper,
			}
			newAggregate := &ArrayAggregate {
				AggregateCommon: *common, 
			}

			flat.Aggregates[t.Path[0]] = newAggregate
		}

		recipeTypes = append(recipeTypes, flat)
	}

	return recipeTypes, nil
}

func calculateActualSize(typ prog.Type) IntegerSize {
	var size uint64 = 0

	if typ.Varlen() {
		fields, _ := getRecordFields(typ)
		for _, field := range fields {
			size += calculateActualSize(field.Type).Size
		}
	} else {
		size = typ.Size()
	}

	intSize := IntegerSize {
		Size: size,
	}

	return intSize
}

func init() {
	flag.StringVar(&outputDir, "output", "recipes_out", "path to directory for generated recipes")
	flag.StringVar(&syzArch, "arch", "arm64", "targeted arch of syzkaller descriptions (sizes or constants might differ) from sys/targets package")

	flag.Usage = func() {
		out := flag.CommandLine.Output()

		fmt.Fprintf(out, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintf(out, "\n")
		fmt.Fprintf(out, "Most importantly ksyzrecip takes at least 1 positional argument which is a path to folder with syzkaller descriptions.\n")
		fmt.Fprintf(out, "Normally that would be in syzkaller/sys/$TARGETOS\n")
	}

	flag.Parse()

	if flag.NArg() == 0 {
		flag.Usage()
		os.Exit(0)
	}

	paths = flag.Args()
}

func main() {
	if len(os.Args) <= 1 {
		flag.Usage()
		os.Exit(0)
	}

	_ = os.Mkdir(outputDir, 0775)
	existingRecipes, _ := filepath.Glob(filepath.Join(outputDir, "*.c"))
	for _, item := range existingRecipes {
		_ = os.RemoveAll(item)
	}

	var descFiles []string
	var constFiles []string

	for _, str := range paths {
		txts, err := filepath.Glob(filepath.Join(str, "*.txt"))
		cnsts, err := filepath.Glob(filepath.Join(str, "*.const"))
		if err != nil {
			panic(err)
		}

		descFiles = append(descFiles, txts...)
		constFiles = append(constFiles, cnsts...)
	}

	var descs *ast.Description = &ast.Description{}
	var p *compiler.Prog = nil
	consts := make(map[string]uint64)

	for p == nil {
		if lastFile != "" && lastMsg != "" {
			fmt.Fprintf(os.Stderr, "error, retrying without file %s: %s\n", lastFile, lastMsg)

			for i, f := range descFiles {
				if lastFile == f {
					descFiles = append(descFiles[:i], descFiles[i+1:]...)
				}
			}

			lastFile = ""
			lastMsg = ""

			descs = &ast.Description{}
			consts = make(map[string]uint64)
		}

		for _, f := range descFiles {
			buf, err := os.ReadFile(f)
			if err != nil {
				panic(err)
			}

			other := ast.Parse(buf, f, func(_ ast.Pos, _ string) {})
			if other != nil {
				descs.Nodes = append(descs.Nodes, other.Nodes...)
			}
		}

		for _, f := range constFiles {
			other := compiler.DeserializeConstFile(f, func(_ ast.Pos, _ string) {}).Arch(targets.ARM64)
			for k, v := range other {
				consts[k] = v
			}
		}

		if len(consts) <= 0 || descs == nil {
			panic("No descriptions nor const got parsed")
		}

		p = compiler.Compile(descs, consts, targets.List[targets.Linux][syzArch], compileErrorHandler)
	}

	prog.RestoreLinks(p.Syscalls, p.Resources, p.Types)

	for _, sc := range p.Syscalls {
		if !strings.HasPrefix(sc.Name, "ioctl$") || len(sc.Args) < 3 {
			continue
		}

		derefed, ok := sc.Args[2].Type.(*prog.PtrType)
		if !ok {
			continue
		}

		inner, ok := derefed.Elem.(*prog.StructType)
		if !ok {
			continue
		}

		recipes, err := generateRecipe(*inner)
		if err != nil {
			continue
		}

		f, err := os.Create(filepath.Join(outputDir, fmt.Sprintf("%s.c", inner.Name())))
		if err != nil {
			continue
		}

		f.WriteString(header)

		for _, recipe := range recipes {
			f.WriteString(recipe.Declaration() + "\n")
		}

		f.WriteString("\n")

		for _, recipe := range recipes {
			f.WriteString(recipe.Definition() + "\n")
		}
	}
}
